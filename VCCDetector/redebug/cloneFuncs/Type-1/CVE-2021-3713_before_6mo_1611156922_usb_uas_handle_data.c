static void usb_uas_handle_data(USBDevice *dev, USBPacket *p)
{
    UASDevice *uas = USB_UAS(dev);
    uas_iu iu;
    UASStatus *st;
    UASRequest *req;
    int length;

    switch (p->ep->nr) {
    case UAS_PIPE_ID_COMMAND:
        length = MIN(sizeof(iu), p->iov.size);
        usb_packet_copy(p, &iu, length);
        switch (iu.hdr.id) {
        case UAS_UI_COMMAND:
            usb_uas_command(uas, &iu);
            break;
        case UAS_UI_TASK_MGMT:
            usb_uas_task(uas, &iu);
            break;
        default:
            error_report("%s: unknown command iu: id 0x%x",
                         __func__, iu.hdr.id);
            p->status = USB_RET_STALL;
            break;
        }
        break;
    case UAS_PIPE_ID_STATUS:
        if (p->stream) {
            QTAILQ_FOREACH(st, &uas->results, next) {
                if (st->stream == p->stream) {
                    break;
                }
            }
            if (st == NULL) {
                assert(uas->status3[p->stream] == NULL);
                uas->status3[p->stream] = p;
                p->status = USB_RET_ASYNC;
                break;
            }
        } else {
            st = QTAILQ_FIRST(&uas->results);
            if (st == NULL) {
                assert(uas->status2 == NULL);
                uas->status2 = p;
                p->status = USB_RET_ASYNC;
                break;
            }
        }
        usb_packet_copy(p, &st->status, st->length);
        QTAILQ_REMOVE(&uas->results, st, next);
        g_free(st);
        break;
    case UAS_PIPE_ID_DATA_IN:
    case UAS_PIPE_ID_DATA_OUT:
        if (p->stream) {
            req = usb_uas_find_request(uas, p->stream);
        } else {
            req = (p->ep->nr == UAS_PIPE_ID_DATA_IN)
                ? uas->datain2 : uas->dataout2;
        }
        if (req == NULL) {
            if (p->stream) {
                assert(uas->data3[p->stream] == NULL);
                uas->data3[p->stream] = p;
                p->status = USB_RET_ASYNC;
                break;
            } else {
                error_report("%s: no inflight request", __func__);
                p->status = USB_RET_STALL;
                break;
            }
        }
        scsi_req_ref(req->req);
        req->data = p;
        usb_uas_copy_data(req);
        if (p->actual_length == p->iov.size || req->complete) {
            req->data = NULL;
        } else {
            req->data_async = true;
            p->status = USB_RET_ASYNC;
        }
        scsi_req_unref(req->req);
        usb_uas_start_next_transfer(uas);
        break;
    default:
        error_report("%s: invalid endpoint %d", __func__, p->ep->nr);
        p->status = USB_RET_STALL;
        break;
    }
}
