static int h264_set_parameter_from_sps(H264Context *h)
{
    MpegEncContext *s = &h->s;

    if (s->flags & CODEC_FLAG_LOW_DELAY ||
        (h->sps.bitstream_restriction_flag &&
         !h->sps.num_reorder_frames)) {
        if (s->avctx->has_b_frames > 1 || h->delayed_pic[0])
            av_log(h->s.avctx, AV_LOG_WARNING, "Delayed frames seen. "
                   "Reenabling low delay requires a codec flush.\n");
        else
            s->low_delay = 1;
    }

    if (s->avctx->has_b_frames < 2)
        s->avctx->has_b_frames = !s->low_delay;

    if (s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||
        h->cur_chroma_format_idc      != h->sps.chroma_format_idc) {
        if (s->avctx->codec &&
            s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU &&
            (h->sps.bit_depth_luma != 8 || h->sps.chroma_format_idc > 1)) {
            av_log(s->avctx, AV_LOG_ERROR,
                   "VDPAU decoding does not support video colorspace.\n");
            return AVERROR_INVALIDDATA;
        }
        if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {
            s->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;
            h->cur_chroma_format_idc      = h->sps.chroma_format_idc;
            h->pixel_shift                = h->sps.bit_depth_luma > 8;

            ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,
                            h->sps.chroma_format_idc);
            ff_h264qpel_init(&h->h264qpel, h->sps.bit_depth_luma);
            ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma,
                              h->sps.chroma_format_idc);
            s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;
            ff_dsputil_init(&s->dsp, s->avctx);
            ff_videodsp_init(&s->vdsp, h->sps.bit_depth_luma);
        } else {
            av_log(s->avctx, AV_LOG_ERROR, "Unsupported bit depth: %d\n",
                   h->sps.bit_depth_luma);
            return AVERROR_INVALIDDATA;
        }
    }
    return 0;
}
