static int
bgp_attr_print(netdissect_options *ndo,
               uint8_t atype, const u_char *pptr, u_int len)
{
    u_int i;
    uint16_t af;
    uint8_t safi, snpa, nhlen;
    int advance;
    u_int tlen;
    const u_char *tptr;
    char buf[MAXHOSTNAMELEN + 100];
    u_int as_size;
    int add_path4, add_path6;
    int ret;

    tptr = pptr;
    tlen = len;

    switch (atype) {
    case BGPTYPE_ORIGIN:
        if (len != 1)
            ND_PRINT("invalid len");
        else {
            ND_TCHECK_1(tptr);
            ND_PRINT("%s", tok2str(bgp_origin_values,
                      "Unknown Origin Typecode",
                      GET_U_1(tptr)));
        }
        break;

    /*
     * Process AS4 byte path and AS2 byte path attributes here.
     */
    case BGPTYPE_AS4_PATH:
    case BGPTYPE_AS_PATH:
        if (len % 2) {
            ND_PRINT("invalid len");
            break;
        }
        if (!len) {
            ND_PRINT("empty");
            break;
        }

        /*
         * BGP updates exchanged between New speakers that support 4
         * byte AS, ASs are always encoded in 4 bytes. There is no
         * definitive way to find this, just by the packet's
         * contents. So, check for packet's TLV's sanity assuming
         * 2 bytes first, and it does not pass, assume that ASs are
         * encoded in 4 bytes format and move on.
         */
        as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);

        while (tptr < pptr + len) {
            ND_TCHECK_1(tptr);
            ND_PRINT("%s", tok2str(bgp_as_path_segment_open_values,
                      "?", GET_U_1(tptr)));
            ND_TCHECK_1(tptr + 1);
            for (i = 0; i < GET_U_1(tptr + 1) * as_size; i += as_size) {
                ND_TCHECK_LEN(tptr + 2 + i, as_size);
                ND_PRINT("%s ",
                          as_printf(ndo, astostr, sizeof(astostr),
                          as_size == 2 ?
                              GET_BE_U_2(tptr + i + 2) :
                              GET_BE_U_4(tptr + i + 2)));
            }
            ND_TCHECK_1(tptr);
            ND_PRINT("%s", tok2str(bgp_as_path_segment_close_values,
                      "?", GET_U_1(tptr)));
            ND_TCHECK_1(tptr + 1);
            tptr += 2 + GET_U_1(tptr + 1) * as_size;
        }
        break;
    case BGPTYPE_NEXT_HOP:
        if (len != 4)
            ND_PRINT("invalid len");
        else {
            ND_TCHECK_4(tptr);
            ND_PRINT("%s", ipaddr_string(ndo, tptr));
        }
        break;
    case BGPTYPE_MULTI_EXIT_DISC:
    case BGPTYPE_LOCAL_PREF:
        if (len != 4)
            ND_PRINT("invalid len");
        else {
            ND_TCHECK_4(tptr);
            ND_PRINT("%u", GET_BE_U_4(tptr));
        }
        break;
    case BGPTYPE_ATOMIC_AGGREGATE:
        if (len != 0)
            ND_PRINT("invalid len");
        break;
    case BGPTYPE_AGGREGATOR:

        /*
         * Depending on the AS encoded is of 2 bytes or of 4 bytes,
         * the length of this PA can be either 6 bytes or 8 bytes.
         */
        if (len != 6 && len != 8) {
            ND_PRINT("invalid len");
            break;
        }
        ND_TCHECK_LEN(tptr, len);
        if (len == 6) {
            ND_PRINT(" AS #%s, origin %s",
                      as_printf(ndo, astostr, sizeof(astostr), GET_BE_U_2(tptr)),
                      ipaddr_string(ndo, tptr + 2));
        } else {
            ND_PRINT(" AS #%s, origin %s",
                      as_printf(ndo, astostr, sizeof(astostr),
                      GET_BE_U_4(tptr)), ipaddr_string(ndo, tptr + 4));
        }
        break;
    case BGPTYPE_AGGREGATOR4:
        if (len != 8) {
            ND_PRINT("invalid len");
            break;
        }
        ND_TCHECK_8(tptr);
        ND_PRINT(" AS #%s, origin %s",
                  as_printf(ndo, astostr, sizeof(astostr), GET_BE_U_4(tptr)),
                  ipaddr_string(ndo, tptr + 4));
        break;
    case BGPTYPE_COMMUNITIES:
        if (len % 4) {
            ND_PRINT("invalid len");
            break;
        }
        while (tlen != 0) {
            uint32_t comm;
            ND_TCHECK_4(tptr);
            if (tlen < 4)
                goto trunc;
            comm = GET_BE_U_4(tptr);
            switch (comm) {
            case BGP_COMMUNITY_NO_EXPORT:
                ND_PRINT(" NO_EXPORT");
                break;
            case BGP_COMMUNITY_NO_ADVERT:
                ND_PRINT(" NO_ADVERTISE");
                break;
            case BGP_COMMUNITY_NO_EXPORT_SUBCONFED:
                ND_PRINT(" NO_EXPORT_SUBCONFED");
                break;
            default:
                ND_PRINT("%u:%u%s",
                         (comm >> 16) & 0xffff,
                         comm & 0xffff,
                         (tlen>4) ? ", " : "");
                break;
            }
            tlen -=4;
            tptr +=4;
        }
        break;
    case BGPTYPE_ORIGINATOR_ID:
        if (len != 4) {
            ND_PRINT("invalid len");
            break;
        }
        ND_TCHECK_4(tptr);
        ND_PRINT("%s",ipaddr_string(ndo, tptr));
        break;
    case BGPTYPE_CLUSTER_LIST:
        if (len % 4) {
            ND_PRINT("invalid len");
            break;
        }
        while (tlen != 0) {
            ND_TCHECK_4(tptr);
            if (tlen < 4)
                goto trunc;
            ND_PRINT("%s%s",
                      ipaddr_string(ndo, tptr),
                      (tlen>4) ? ", " : "");
            tlen -=4;
            tptr +=4;
        }
        break;
    case BGPTYPE_MP_REACH_NLRI:
        ND_TCHECK_3(tptr);
        if (tlen < 3)
            goto trunc;
	ret = bgp_mp_af_print(ndo, tptr, tlen, &af, &safi);
	if (ret == -2)
	    goto trunc;
	if (ret < 0)
	    break;

        tptr +=3;

        ND_TCHECK_1(tptr);
        nhlen = GET_U_1(tptr);
        tlen = nhlen;
        tptr++;

        if (tlen) {
            u_int nnh = 0;
            ND_PRINT("\n\t    nexthop: ");
            while (tlen != 0) {
                if (nnh++ > 0) {
                    ND_PRINT(", " );
                }
                switch(af<<8 | safi) {
                case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):
                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):
                case (AFNUM_INET<<8 | SAFNUM_MDT):
                    if (tlen < sizeof(nd_ipv4)) {
                        ND_PRINT("invalid len");
                        tlen = 0;
                    } else {
                        ND_TCHECK_LEN(tptr, sizeof(nd_ipv4));
                        ND_PRINT("%s",ipaddr_string(ndo, tptr));
                        tlen -= sizeof(nd_ipv4);
                        tptr += sizeof(nd_ipv4);
                    }
                    break;
                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                    if (tlen < sizeof(nd_ipv4)+BGP_VPN_RD_LEN) {
                        ND_PRINT("invalid len");
                        tlen = 0;
                    } else {
                        ND_TCHECK_LEN(tptr,
                                      sizeof(nd_ipv4) + BGP_VPN_RD_LEN);
                        ND_PRINT("RD: %s, %s",
                                  bgp_vpn_rd_print(ndo, tptr),
                                  ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN));
                        tlen -= (sizeof(nd_ipv4)+BGP_VPN_RD_LEN);
                        tptr += (sizeof(nd_ipv4)+BGP_VPN_RD_LEN);
                    }
                    break;
                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                    if (tlen < sizeof(nd_ipv6)) {
                        ND_PRINT("invalid len");
                        tlen = 0;
                    } else {
                        ND_TCHECK_LEN(tptr, sizeof(nd_ipv6));
                        ND_PRINT("%s", ip6addr_string(ndo, tptr));
                        tlen -= sizeof(nd_ipv6);
                        tptr += sizeof(nd_ipv6);
                    }
                    break;
                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                    if (tlen < sizeof(nd_ipv6)+BGP_VPN_RD_LEN) {
                        ND_PRINT("invalid len");
                        tlen = 0;
                    } else {
                        ND_TCHECK_LEN(tptr,
                                      sizeof(nd_ipv6) + BGP_VPN_RD_LEN);
                        ND_PRINT("RD: %s, %s",
                                  bgp_vpn_rd_print(ndo, tptr),
                                  ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN));
                        tlen -= (sizeof(nd_ipv6)+BGP_VPN_RD_LEN);
                        tptr += (sizeof(nd_ipv6)+BGP_VPN_RD_LEN);
                    }
                    break;
                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                    if (tlen < sizeof(nd_ipv4)) {
                        ND_PRINT("invalid len");
                        tlen = 0;
                    } else {
                        ND_TCHECK_LEN(tptr, sizeof(nd_ipv4));
                        ND_PRINT("%s", ipaddr_string(ndo, tptr));
                        tlen -= (sizeof(nd_ipv4));
                        tptr += (sizeof(nd_ipv4));
                    }
                    break;
                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                    ND_TCHECK_LEN(tptr, tlen);
                    ND_PRINT("%s", isonsap_string(ndo, tptr, tlen));
                    tptr += tlen;
                    tlen = 0;
                    break;

                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                    if (tlen < BGP_VPN_RD_LEN+1) {
                        ND_PRINT("invalid len");
                        tlen = 0;
                    } else {
                        ND_TCHECK_LEN(tptr, tlen);
                        ND_PRINT("RD: %s, %s",
                                  bgp_vpn_rd_print(ndo, tptr),
                                  isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN));
                        /* rfc986 mapped IPv4 address ? */
                        if (GET_BE_U_4(tptr + BGP_VPN_RD_LEN) ==  0x47000601)
                            ND_PRINT(" = %s", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4));
                        /* rfc1888 mapped IPv6 address ? */
                        else if (GET_BE_U_3(tptr + BGP_VPN_RD_LEN) ==  0x350000)
                            ND_PRINT(" = %s", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3));
                        tptr += tlen;
                        tlen = 0;
                    }
                    break;
                default:
		    /*
		     * bgp_mp_af_print() should have saved us from
		     * an unsupported AFI/SAFI.
		     */
                    ND_PRINT("ERROR: no AFI %u/SAFI %u nexthop decoder", af, safi);
                    tptr += tlen;
                    tlen = 0;
                    goto done;
                    break;
                }
            }
        }
        ND_PRINT(", nh-length: %u", nhlen);
        tptr += tlen;

        ND_TCHECK_1(tptr);
        snpa = GET_U_1(tptr);
        tptr++;

        if (snpa) {
            ND_PRINT("\n\t    %u SNPA", snpa);
            for (/*nothing*/; snpa != 0; snpa--) {
                ND_TCHECK_1(tptr);
                ND_PRINT("\n\t      %u bytes", GET_U_1(tptr));
                tptr += GET_U_1(tptr) + 1;
            }
        } else {
            ND_PRINT(", no SNPA");
        }

        add_path4 = check_add_path(ndo, tptr, (len-ND_BYTES_BETWEEN(tptr, pptr)), 32);
        add_path6 = check_add_path(ndo, tptr, (len-ND_BYTES_BETWEEN(tptr, pptr)), 128);

        while (tptr < pptr + len) {
            advance = bgp_nlri_print(ndo, af, safi, tptr, len, buf, sizeof(buf),
                    add_path4, add_path6);
            if (advance == -2)
                goto trunc;
            if (advance < 0)
                break;
            tptr += advance;
        }
        break;

    case BGPTYPE_MP_UNREACH_NLRI:
        ND_TCHECK_LEN(tptr, BGP_MP_NLRI_MINSIZE);
	ret = bgp_mp_af_print(ndo, tptr, tlen, &af, &safi);
	if (ret == -2)
	    goto trunc;
	if (ret < 0)
	    break;

        if (len == BGP_MP_NLRI_MINSIZE)
            ND_PRINT("\n\t      End-of-Rib Marker (empty NLRI)");

        tptr += 3;

        add_path4 = check_add_path(ndo, tptr, (len-ND_BYTES_BETWEEN(tptr, pptr)), 32);
        add_path6 = check_add_path(ndo, tptr, (len-ND_BYTES_BETWEEN(tptr, pptr)), 128);

        while (tptr < pptr + len) {
            advance = bgp_nlri_print(ndo, af, safi, tptr, len, buf, sizeof(buf),
                    add_path4, add_path6);
            if (advance == -2)
                goto trunc;
            if (advance < 0)
                break;
            tptr += advance;
        }
        break;
    case BGPTYPE_EXTD_COMMUNITIES:
        if (len % 8) {
            ND_PRINT("invalid len");
            break;
        }
        while (tlen != 0) {
            uint16_t extd_comm;

            ND_TCHECK_2(tptr);
            if (tlen < 2)
                goto trunc;
            extd_comm=GET_BE_U_2(tptr);

            ND_PRINT("\n\t    %s (0x%04x), Flags [%s]",
                      tok2str(bgp_extd_comm_subtype_values,
                              "unknown extd community typecode",
                              extd_comm),
                      extd_comm,
                      bittok2str(bgp_extd_comm_flag_values, "none", extd_comm));

            ND_TCHECK_8(tptr);
            if (tlen < 8)
                goto trunc;
            ND_PRINT(": ");
            bgp_extended_community_print(ndo, tptr);
            tlen -= 8;
            tptr += 8;
        }
        break;

    case BGPTYPE_PMSI_TUNNEL:
    {
        uint8_t tunnel_type, flags;

        ND_TCHECK_5(tptr);
        if (tlen < 5)
            goto trunc;
        flags = GET_U_1(tptr);
        tunnel_type = GET_U_1(tptr + 1);
        tlen = len;

        ND_PRINT("\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u",
                  tok2str(bgp_pmsi_tunnel_values, "Unknown", tunnel_type),
                  tunnel_type,
                  bittok2str(bgp_pmsi_flag_values, "none", flags),
                  GET_BE_U_3(tptr + 2)>>4);

        tptr +=5;
        tlen -= 5;

        switch (tunnel_type) {
        case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */
        case BGP_PMSI_TUNNEL_PIM_BIDIR:
            ND_TCHECK_8(tptr);
            ND_PRINT("\n\t      Sender %s, P-Group %s",
                      ipaddr_string(ndo, tptr),
                      ipaddr_string(ndo, tptr+4));
            break;

        case BGP_PMSI_TUNNEL_PIM_SSM:
            ND_TCHECK_8(tptr);
            ND_PRINT("\n\t      Root-Node %s, P-Group %s",
                      ipaddr_string(ndo, tptr),
                      ipaddr_string(ndo, tptr+4));
            break;
        case BGP_PMSI_TUNNEL_INGRESS:
            ND_TCHECK_4(tptr);
            ND_PRINT("\n\t      Tunnel-Endpoint %s",
                      ipaddr_string(ndo, tptr));
            break;
        case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */
        case BGP_PMSI_TUNNEL_LDP_MP2MP:
            ND_TCHECK_8(tptr);
            ND_PRINT("\n\t      Root-Node %s, LSP-ID 0x%08x",
                      ipaddr_string(ndo, tptr),
                      GET_BE_U_4(tptr + 4));
            break;
        case BGP_PMSI_TUNNEL_RSVP_P2MP:
            ND_TCHECK_8(tptr);
            ND_PRINT("\n\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x",
                      ipaddr_string(ndo, tptr),
                      GET_BE_U_4(tptr + 4));
            break;
        default:
            if (ndo->ndo_vflag <= 1) {
                print_unknown_data(ndo, tptr, "\n\t      ", tlen);
            }
        }
        break;
    }
    case BGPTYPE_AIGP:
    {
        uint8_t type;
        uint16_t length;

        tlen = len;

        while (tlen >= 3) {

            ND_TCHECK_3(tptr);

            type = GET_U_1(tptr);
            length = GET_BE_U_2(tptr + 1);
            tptr += 3;
            tlen -= 3;

            ND_PRINT("\n\t    %s TLV (%u), length %u",
                      tok2str(bgp_aigp_values, "Unknown", type),
                      type, length);

            if (length < 3)
                goto trunc;
            length -= 3;

            /*
             * Check if we can read the TLV data.
             */
            ND_TCHECK_LEN(tptr + 3, length);
            if (tlen < length)
                goto trunc;

            switch (type) {

            case BGP_AIGP_TLV:
                if (length < 8)
                    goto trunc;
                ND_PRINT(", metric %" PRIu64,
                          GET_BE_U_8(tptr));
                break;

            default:
                if (ndo->ndo_vflag <= 1) {
                    print_unknown_data(ndo, tptr,"\n\t      ", length);
                }
            }

            tptr += length;
            tlen -= length;
        }
        break;
    }
    case BGPTYPE_ATTR_SET:
        ND_TCHECK_4(tptr);
        if (len < 4)
            goto trunc;
        ND_PRINT("\n\t    Origin AS: %s",
                  as_printf(ndo, astostr, sizeof(astostr), GET_BE_U_4(tptr)));
        tptr += 4;
        len -= 4;

        while (len) {
            u_int aflags, alenlen, alen;

            ND_TCHECK_2(tptr);
            if (len < 2) {
                ND_PRINT(" [path attr too short]");
                tptr += len;
                break;
            }
            aflags = GET_U_1(tptr);
            atype = GET_U_1(tptr + 1);
            tptr += 2;
            len -= 2;
            alenlen = bgp_attr_lenlen(aflags, tptr);
            ND_TCHECK_LEN(tptr, alenlen);
            if (len < alenlen) {
                ND_PRINT(" [path attr too short]");
                tptr += len;
                break;
            }
            alen = bgp_attr_len(aflags, tptr);
            tptr += alenlen;
            len -= alenlen;

            ND_PRINT("\n\t      %s (%u), length: %u",
                      tok2str(bgp_attr_values,
                              "Unknown Attribute", atype),
                      atype,
                      alen);

            if (aflags) {
                ND_PRINT(", Flags [%s%s%s%s",
                          aflags & 0x80 ? "O" : "",
                          aflags & 0x40 ? "T" : "",
                          aflags & 0x20 ? "P" : "",
                          aflags & 0x10 ? "E" : "");
                if (aflags & 0xf)
                    ND_PRINT("+%x", aflags & 0xf);
                ND_PRINT("]");
            }
            ND_PRINT(": ");
            if (len < alen) {
                ND_PRINT(" [path attr too short]");
                tptr += len;
                break;
            }
            /* FIXME check for recursion */
            if (!bgp_attr_print(ndo, atype, tptr, alen))
                return 0;
            tptr += alen;
            len -= alen;
        }
        break;

    case BGPTYPE_LARGE_COMMUNITY:
        if (len == 0 || len % 12) {
            ND_PRINT("invalid len");
            break;
        }
        ND_PRINT("\n\t    ");
        while (len != 0) {
            ND_TCHECK_LEN(tptr, 12);
            ND_PRINT("%u:%u:%u%s",
                      GET_BE_U_4(tptr),
                      GET_BE_U_4(tptr + 4),
                      GET_BE_U_4(tptr + 8),
                      (len > 12) ? ", " : "");
            tptr += 12;
            /*
             * len will always be a multiple of 12, as per the above,
             * so this will never underflow.
             */
            len -= 12;
        }
        break;
    default:
        ND_TCHECK_LEN(pptr, len);
        ND_PRINT("\n\t    no Attribute %u decoder", atype); /* we have no decoder for the attribute */
        if (ndo->ndo_vflag <= 1)
            print_unknown_data(ndo, pptr, "\n\t    ", len);
        break;
    }
done:
    if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/
        ND_TCHECK_LEN(pptr, len);
        print_unknown_data(ndo, pptr, "\n\t    ", len);
    }
    return 1;

trunc:
    return 0;
}
