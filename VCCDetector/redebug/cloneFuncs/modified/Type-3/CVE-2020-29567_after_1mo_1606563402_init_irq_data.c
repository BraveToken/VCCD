int __init init_irq_data(void)
{
    struct irq_desc *desc;
    int irq, vector;

    for ( vector = 0; vector < X86_NR_VECTORS; ++vector )
        this_cpu(vector_irq)[vector] = INT_MIN;

    irq_desc = xzalloc_array(struct irq_desc, nr_irqs);
    
    if ( !irq_desc )
        return -ENOMEM;

    for ( irq = 0; irq < nr_irqs_gsi; irq++ )
    {
        int rc;

        desc = irq_to_desc(irq);
        desc->irq = irq;

        rc = init_one_irq_desc(desc);
        if ( rc )
            return rc;
    }
    for ( ; irq < nr_irqs; irq++ )
        irq_to_desc(irq)->irq = irq;

    if ( !irq_max_guests )
        irq_max_guests = 32;

#ifdef CONFIG_PV
    /* Never allocate the Linux/BSD fast-trap vector. */
    set_bit(LEGACY_SYSCALL_VECTOR, used_vectors);
#endif

#ifdef CONFIG_PV32
    /* Never allocate the hypercall vector. */
    set_bit(HYPERCALL_VECTOR, used_vectors);
#endif
    
    /*
     * Mark vectors up to the cleanup one as used, to prevent an infinite loop
     * invoking irq_move_cleanup_interrupt.
     */
    BUILD_BUG_ON(IRQ_MOVE_CLEANUP_VECTOR < FIRST_DYNAMIC_VECTOR);
    for ( vector = FIRST_DYNAMIC_VECTOR;
          vector <= IRQ_MOVE_CLEANUP_VECTOR;
          vector++ )
        __set_bit(vector, used_vectors);

    return 0;
}
