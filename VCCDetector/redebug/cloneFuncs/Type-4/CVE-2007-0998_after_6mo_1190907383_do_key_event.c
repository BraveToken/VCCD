static void do_key_event(VncState *vs, int down, uint32_t sym)
{
    int keycode;
    int shift_keys = 0;
    int shift = 0;

    if (is_graphic_console()) {
        if (sym >= 'A' && sym <= 'Z') {
            sym = sym - 'A' + 'a';
            shift = 1;
        }
        else {
            shift = keysymIsShift(vs->kbd_layout, sym & 0xFFFF);
        }
    }
    shift_keys = vs->modifiers_state[0x2a] | vs->modifiers_state[0x36];

    keycode = keysym2scancode(vs->kbd_layout, sym & 0xFFFF);
    if (keycode == 0) {
        fprintf(stderr, "Key lost : keysym=0x%x(%d)\n", sym, sym);
        return;
    }

    /* QEMU console switch */
    switch(keycode) {
    case 0x2a:                          /* Left Shift */
    case 0x36:                          /* Right Shift */
    case 0x1d:                          /* Left CTRL */
    case 0x9d:                          /* Right CTRL */
    case 0x38:                          /* Left ALT */
    case 0xb8:                          /* Right ALT */
        if (down) {
            vs->modifiers_state[keycode] = 1;
            kbd_put_keycode(keycode & 0x7f);
        }
        else {
            vs->modifiers_state[keycode] = 0;
            kbd_put_keycode(keycode | 0x80);
        }
        return;
    case 0x02 ... 0x0a: /* '1' to '9' keys */ 
        if (down && vs->modifiers_state[0x1d] && vs->modifiers_state[0x38]) {
            /* Reset the modifiers sent to the current console */
            reset_keys(vs);
            console_select(keycode - 0x02);
            return;
        }
        break;
    case 0x45:			/* NumLock */
	if (down) {
            kbd_put_keycode(keycode & 0x7f);
        }
        else {	
	    vs->modifiers_state[keycode] ^= 1;
            kbd_put_keycode(keycode | 0x80);
        }
	return;
    }

    if (keycodeIsKeypad(vs->kbd_layout, keycode)) {
        /* If the numlock state needs to change then simulate an additional
           keypress before sending this one.  This will happen if the user
           toggles numlock away from the VNC window.
        */
        if (keysymIsNumlock(vs->kbd_layout, sym & 0xFFFF)) {
	    if (!vs->modifiers_state[0x45]) {
		vs->modifiers_state[0x45] = 1;
		press_key(vs, 0xff7f);
	    }
	} else {
	    if (vs->modifiers_state[0x45]) {
		vs->modifiers_state[0x45] = 0;
		press_key(vs, 0xff7f);
	    }
        }
    }

    if (is_graphic_console()) {
        /*  If the shift state needs to change then simulate an additional
            keypress before sending this one.
        */
        if (shift && !shift_keys) {
            press_key_shift_down(vs, down, keycode);
            return;
        }
        else if (!shift && shift_keys) {
            press_key_shift_up(vs, down, keycode);
            return;
        }

        if (keycode & 0x80)
            kbd_put_keycode(0xe0);
        if (down)
            kbd_put_keycode(keycode & 0x7f);
        else
            kbd_put_keycode(keycode | 0x80);
    } else {
        /* QEMU console emulation */
        if (down) {
            switch (keycode) {
            case 0x2a:                          /* Left Shift */
            case 0x36:                          /* Right Shift */
            case 0x1d:                          /* Left CTRL */
            case 0x9d:                          /* Right CTRL */
            case 0x38:                          /* Left ALT */
            case 0xb8:                          /* Right ALT */
                break;
            case 0xc8:
                kbd_put_keysym(QEMU_KEY_UP);
                break;
            case 0xd0:
                kbd_put_keysym(QEMU_KEY_DOWN);
                break;
            case 0xcb:
                kbd_put_keysym(QEMU_KEY_LEFT);
                break;
            case 0xcd:
                kbd_put_keysym(QEMU_KEY_RIGHT);
                break;
            case 0xd3:
                kbd_put_keysym(QEMU_KEY_DELETE);
                break;
            case 0xc7:
                kbd_put_keysym(QEMU_KEY_HOME);
                break;
            case 0xcf:
                kbd_put_keysym(QEMU_KEY_END);
                break;
            case 0xc9:
                kbd_put_keysym(QEMU_KEY_PAGEUP);
                break;
            case 0xd1:
                kbd_put_keysym(QEMU_KEY_PAGEDOWN);
                break;
            default:
                kbd_put_keysym(sym);
                break;
            }
        }
    }
}
