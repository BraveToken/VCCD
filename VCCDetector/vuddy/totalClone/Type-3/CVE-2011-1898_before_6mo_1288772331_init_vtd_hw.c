static int init_vtd_hw(void)
{
    struct acpi_drhd_unit *drhd;
    struct iommu *iommu;
    struct iommu_flush *flush = NULL;
    int irq;
    int ret;
    unsigned long flags;
    struct irq_cfg *cfg;

    for_each_drhd_unit ( drhd )
    {
        iommu = drhd->iommu;
        if ( iommu->irq < 0 )
        {
            irq = iommu_set_interrupt(iommu);
            if ( irq < 0 )
            {
                dprintk(XENLOG_ERR VTDPREFIX, "IOMMU: interrupt setup failed\n");
                return irq;
            }
            iommu->irq = irq;
        }

        cfg = irq_cfg(iommu->irq);
        dma_msi_set_affinity(iommu->irq, cfg->cpu_mask);

        clear_fault_bits(iommu);

        spin_lock_irqsave(&iommu->register_lock, flags);
        dmar_writel(iommu->reg, DMAR_FECTL_REG, 0);
        spin_unlock_irqrestore(&iommu->register_lock, flags);
    }

    for_each_drhd_unit ( drhd )
    {
        iommu = drhd->iommu;
        /*
         * If queued invalidation not enabled, use regiser based
         * invalidation
         */
        if ( enable_qinval(iommu) != 0 )
        {
            flush = iommu_get_flush(iommu);
            flush->context = flush_context_reg;
            flush->iotlb = flush_iotlb_reg;
        }
    }

    if ( iommu_intremap )
    {
        int apic;
        for ( apic = 0; apic < nr_ioapics; apic++ )
        {
            if ( ioapic_to_iommu(IO_APIC_ID(apic)) == NULL )
            {
                iommu_intremap = 0;
                dprintk(XENLOG_ERR VTDPREFIX,
                    "ioapic_to_iommu: ioapic 0x%x (id: 0x%x) is NULL! "
                    "Will not try to enable Interrupt Remapping.\n",
                    apic, IO_APIC_ID(apic));
                break;
            }
        }
    }

    if ( iommu_intremap )
    {
        for_each_drhd_unit ( drhd )
        {
            iommu = drhd->iommu;
            if ( enable_intremap(iommu, 0) != 0 )
            {
                dprintk(XENLOG_WARNING VTDPREFIX,
                        "Failed to enable Interrupt Remapping!\n");
                break;
            }
        }
    }

    for_each_drhd_unit ( drhd )
    {
        iommu = drhd->iommu;
        ret = iommu_set_root_entry(iommu);
        if ( ret )
        {
            dprintk(XENLOG_ERR VTDPREFIX, "IOMMU: set root entry failed\n");
            return -EIO;
        }
    }

    /*
     * After set root entry, must globally invalidate context cache, and
     * then globally invalidate IOTLB
     */
    iommu_flush_all();

    return 0;
}
