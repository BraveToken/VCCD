void
udp_print(netdissect_options *ndo, register const u_char *bp, u_int length,
	  register const u_char *bp2, int fragmented)
{
	register const struct udphdr *up;
	register const struct ip *ip;
	register const u_char *cp;
	register const u_char *ep = bp + length;
	uint16_t sport, dport, ulen;
#ifdef INET6
	register const struct ip6_hdr *ip6;
#endif

	if (ep > ndo->ndo_snapend)
		ep = ndo->ndo_snapend;
	up = (const struct udphdr *)bp;
	ip = (const struct ip *)bp2;
#ifdef INET6
	if (IP_V(ip) == 6)
		ip6 = (const struct ip6_hdr *)bp2;
	else
		ip6 = NULL;
#endif /*INET6*/
	if (!ND_TTEST(up->uh_dport)) {
		udpipaddr_print(ndo, ip, -1, -1);
		ND_PRINT((ndo, "[|udp]"));
		return;
	}

	sport = EXTRACT_16BITS(&up->uh_sport);
	dport = EXTRACT_16BITS(&up->uh_dport);

	if (length < sizeof(struct udphdr)) {
		udpipaddr_print(ndo, ip, sport, dport);
		ND_PRINT((ndo, "truncated-udp %d", length));
		return;
	}
	ulen = EXTRACT_16BITS(&up->uh_ulen);
	if (ulen < sizeof(struct udphdr)) {
		udpipaddr_print(ndo, ip, sport, dport);
		ND_PRINT((ndo, "truncated-udplength %d", ulen));
		return;
	}
	ulen -= sizeof(struct udphdr);
	length -= sizeof(struct udphdr);
	if (ulen < length)
		length = ulen;

	cp = (const u_char *)(up + 1);
	if (cp > ndo->ndo_snapend) {
		udpipaddr_print(ndo, ip, sport, dport);
		ND_PRINT((ndo, "[|udp]"));
		return;
	}

	if (ndo->ndo_packettype) {
		register const struct sunrpc_msg *rp;
		enum sunrpc_msg_type direction;

		switch (ndo->ndo_packettype) {

		case PT_VAT:
			udpipaddr_print(ndo, ip, sport, dport);
			vat_print(ndo, (const void *)(up + 1), up);
			break;

		case PT_WB:
			udpipaddr_print(ndo, ip, sport, dport);
			wb_print(ndo, (const void *)(up + 1), length);
			break;

		case PT_RPC:
			rp = (const struct sunrpc_msg *)(up + 1);
			direction = (enum sunrpc_msg_type)EXTRACT_32BITS(&rp->rm_direction);
			if (direction == SUNRPC_CALL)
				sunrpcrequest_print(ndo, (const u_char *)rp, length,
				    (const u_char *)ip);
			else
				nfsreply_print(ndo, (const u_char *)rp, length,
				    (const u_char *)ip);			/*XXX*/
			break;

		case PT_RTP:
			udpipaddr_print(ndo, ip, sport, dport);
			rtp_print(ndo, (const void *)(up + 1), length, up);
			break;

		case PT_RTCP:
			udpipaddr_print(ndo, ip, sport, dport);
			while (cp < ep)
				cp = rtcp_print(ndo, cp, ep);
			break;

		case PT_SNMP:
			udpipaddr_print(ndo, ip, sport, dport);
			snmp_print(ndo, (const u_char *)(up + 1), length);
			break;

		case PT_CNFP:
			udpipaddr_print(ndo, ip, sport, dport);
			cnfp_print(ndo, cp);
			break;

		case PT_TFTP:
			udpipaddr_print(ndo, ip, sport, dport);
			tftp_print(ndo, cp, length);
			break;

		case PT_AODV:
			udpipaddr_print(ndo, ip, sport, dport);
			aodv_print(ndo, (const u_char *)(up + 1), length,
#ifdef INET6
			    ip6 != NULL);
#else
			    0);
#endif
			break;

		case PT_RADIUS:
			udpipaddr_print(ndo, ip, sport, dport);
			radius_print(ndo, cp, length);
			break;

		case PT_VXLAN:
			udpipaddr_print(ndo, ip, sport, dport);
			vxlan_print(ndo, (const u_char *)(up + 1), length);
			break;

		case PT_PGM:
		case PT_PGM_ZMTP1:
			udpipaddr_print(ndo, ip, sport, dport);
			pgm_print(ndo, cp, length, bp2);
			break;
		case PT_LMP:
			udpipaddr_print(ndo, ip, sport, dport);
			lmp_print(ndo, cp, length);
			break;
		}
		return;
	}

	udpipaddr_print(ndo, ip, sport, dport);
	if (!ndo->ndo_qflag) {
		register const struct sunrpc_msg *rp;
		enum sunrpc_msg_type direction;

		rp = (const struct sunrpc_msg *)(up + 1);
		if (ND_TTEST(rp->rm_direction)) {
			direction = (enum sunrpc_msg_type)EXTRACT_32BITS(&rp->rm_direction);
			if (dport == NFS_PORT && direction == SUNRPC_CALL) {
				ND_PRINT((ndo, "NFS request xid %u ", EXTRACT_32BITS(&rp->rm_xid)));
				nfsreq_print_noaddr(ndo, (const u_char *)rp, length,
				    (const u_char *)ip);
				return;
			}
			if (sport == NFS_PORT && direction == SUNRPC_REPLY) {
				ND_PRINT((ndo, "NFS reply xid %u ", EXTRACT_32BITS(&rp->rm_xid)));
				nfsreply_print_noaddr(ndo, (const u_char *)rp, length,
				    (const u_char *)ip);
				return;
			}
#ifdef notdef
			if (dport == SUNRPC_PORT && direction == SUNRPC_CALL) {
				sunrpcrequest_print((const u_char *)rp, length, (const u_char *)ip);
				return;
			}
#endif
		}
		if (ND_TTEST(((const struct LAP *)cp)->type) &&
		    ((const struct LAP *)cp)->type == lapDDP &&
		    (atalk_port(sport) || atalk_port(dport))) {
			if (ndo->ndo_vflag)
				ND_PRINT((ndo, "kip "));
			llap_print(ndo, cp, length);
			return;
		}
	}

	if (ndo->ndo_vflag && !ndo->ndo_Kflag && !fragmented) {
                /* Check the checksum, if possible. */
                uint16_t sum, udp_sum;

		/*
		 * XXX - do this even if vflag == 1?
		 * TCP does, and we do so for UDP-over-IPv6.
		 */
	        if (IP_V(ip) == 4 && (ndo->ndo_vflag > 1)) {
			udp_sum = EXTRACT_16BITS(&up->uh_sum);
			if (udp_sum == 0) {
				ND_PRINT((ndo, "[no cksum] "));
			} else if (ND_TTEST2(cp[0], length)) {
				sum = udp_cksum(ndo, ip, up, length + sizeof(struct udphdr));

	                        if (sum != 0) {
					ND_PRINT((ndo, "[bad udp cksum 0x%04x -> 0x%04x!] ",
					    udp_sum,
					    in_cksum_shouldbe(udp_sum, sum)));
				} else
					ND_PRINT((ndo, "[udp sum ok] "));
			}
		}
#ifdef INET6
		else if (IP_V(ip) == 6 && ip6->ip6_plen) {
			/* for IPv6, UDP checksum is mandatory */
			if (ND_TTEST2(cp[0], length)) {
				sum = udp6_cksum(ip6, up, length + sizeof(struct udphdr));
				udp_sum = EXTRACT_16BITS(&up->uh_sum);

	                        if (sum != 0) {
					ND_PRINT((ndo, "[bad udp cksum 0x%04x -> 0x%04x!] ",
					    udp_sum,
					    in_cksum_shouldbe(udp_sum, sum)));
				} else
					ND_PRINT((ndo, "[udp sum ok] "));
			}
		}
#endif
	}

	if (!ndo->ndo_qflag) {
#define ISPORT(p) (dport == (p) || sport == (p))
		if (ISPORT(NAMESERVER_PORT))
			ns_print(ndo, (const u_char *)(up + 1), length, 0);
		else if (ISPORT(MULTICASTDNS_PORT))
			ns_print(ndo, (const u_char *)(up + 1), length, 1);
		else if (ISPORT(TIMED_PORT))
			timed_print(ndo, (const u_char *)(up + 1));
		else if (ISPORT(TFTP_PORT))
			tftp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(BOOTPC_PORT) || ISPORT(BOOTPS_PORT))
			bootp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(RIP_PORT))
			rip_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(AODV_PORT))
			aodv_print(ndo, (const u_char *)(up + 1), length,
#ifdef INET6
			    ip6 != NULL);
#else
			    0);
#endif
	        else if (ISPORT(ISAKMP_PORT))
			 isakmp_print(ndo, (const u_char *)(up + 1), length, bp2);
  	        else if (ISPORT(ISAKMP_PORT_NATT))
			 isakmp_rfc3948_print(ndo, (const u_char *)(up + 1), length, bp2);
#if 1 /*???*/
   	        else if (ISPORT(ISAKMP_PORT_USER1) || ISPORT(ISAKMP_PORT_USER2))
			isakmp_print(ndo, (const u_char *)(up + 1), length, bp2);
#endif
		else if (ISPORT(SNMP_PORT) || ISPORT(SNMPTRAP_PORT))
			snmp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(NTP_PORT))
			ntp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(KERBEROS_PORT) || ISPORT(KERBEROS_SEC_PORT))
			krb_print(ndo, (const void *)(up + 1));
		else if (ISPORT(L2TP_PORT))
			l2tp_print(ndo, (const u_char *)(up + 1), length);
#ifdef TCPDUMP_DO_SMB
		else if (ISPORT(NETBIOS_NS_PORT))
			nbt_udp137_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(NETBIOS_DGRAM_PORT))
			nbt_udp138_print(ndo, (const u_char *)(up + 1), length);
#endif
		else if (dport == VAT_PORT)
			vat_print(ndo, (const void *)(up + 1), up);
		else if (ISPORT(ZEPHYR_SRV_PORT) || ISPORT(ZEPHYR_CLT_PORT))
			zephyr_print(ndo, (const void *)(up + 1), length);
		/*
		 * Since there are 10 possible ports to check, I think
		 * a <> test would be more efficient
		 */
		else if ((sport >= RX_PORT_LOW && sport <= RX_PORT_HIGH) ||
			 (dport >= RX_PORT_LOW && dport <= RX_PORT_HIGH))
			rx_print(ndo, (const void *)(up + 1), length, sport, dport,
				 (const u_char *) ip);
#ifdef INET6
		else if (ISPORT(RIPNG_PORT))
			ripng_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(DHCP6_SERV_PORT) || ISPORT(DHCP6_CLI_PORT))
			dhcp6_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(AHCP_PORT))
			ahcp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(BABEL_PORT) || ISPORT(BABEL_PORT_OLD))
			babel_print(ndo, (const u_char *)(up + 1), length);
#endif /*INET6*/
		/*
		 * Kludge in test for whiteboard packets.
		 */
		else if (dport == WB_PORT)
			wb_print(ndo, (const void *)(up + 1), length);
		else if (ISPORT(CISCO_AUTORP_PORT))
			cisco_autorp_print(ndo, (const void *)(up + 1), length);
		else if (ISPORT(RADIUS_PORT) ||
			 ISPORT(RADIUS_NEW_PORT) ||
			 ISPORT(RADIUS_ACCOUNTING_PORT) ||
			 ISPORT(RADIUS_NEW_ACCOUNTING_PORT) ||
			 ISPORT(RADIUS_COA_PORT) )
			radius_print(ndo, (const u_char *)(up+1), length);
		else if (dport == HSRP_PORT)
			hsrp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(LWRES_PORT))
			lwres_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(LDP_PORT))
			ldp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(OLSR_PORT))
			olsr_print(ndo, (const u_char *)(up + 1), length,
#if INET6
					(IP_V(ip) == 6) ? 1 : 0);
#else
					0);
#endif
		else if (ISPORT(MPLS_LSP_PING_PORT))
			lspping_print(ndo, (const u_char *)(up + 1), length);
		else if (dport == BFD_CONTROL_PORT ||
			 dport == BFD_ECHO_PORT )
			bfd_print(ndo, (const u_char *)(up+1), length, dport);
                else if (ISPORT(LMP_PORT))
			lmp_print(ndo, (const u_char *)(up + 1), length);
		else if (ISPORT(VQP_PORT))
			vqp_print(ndo, (const u_char *)(up + 1), length);
                else if (ISPORT(SFLOW_PORT))
                        sflow_print(ndo, (const u_char *)(up + 1), length);
	        else if (dport == LWAPP_CONTROL_PORT)
			lwapp_control_print(ndo, (const u_char *)(up + 1), length, 1);
                else if (sport == LWAPP_CONTROL_PORT)
                        lwapp_control_print(ndo, (const u_char *)(up + 1), length, 0);
                else if (ISPORT(LWAPP_DATA_PORT))
                        lwapp_data_print(ndo, (const u_char *)(up + 1), length);
                else if (ISPORT(SIP_PORT))
			sip_print(ndo, (const u_char *)(up + 1), length);
                else if (ISPORT(SYSLOG_PORT))
			syslog_print(ndo, (const u_char *)(up + 1), length);
                else if (ISPORT(OTV_PORT))
			otv_print(ndo, (const u_char *)(up + 1), length);
                else if (ISPORT(VXLAN_PORT))
			vxlan_print(ndo, (const u_char *)(up + 1), length);
                else if (ISPORT(GENEVE_PORT))
			geneve_print(ndo, (const u_char *)(up + 1), length);
		else {
			if (ulen > length)
				ND_PRINT((ndo, "UDP, bad length %u > %u",
				    ulen, length));
			else
				ND_PRINT((ndo, "UDP, length %u", ulen));
		}
#undef ISPORT
	} else {
		if (ulen > length)
			ND_PRINT((ndo, "UDP, bad length %u > %u",
			    ulen, length));
		else
			ND_PRINT((ndo, "UDP, length %u", ulen));
	}
}
