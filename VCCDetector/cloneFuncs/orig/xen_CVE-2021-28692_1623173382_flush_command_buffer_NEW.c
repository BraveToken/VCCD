static void flush_command_buffer(struct amd_iommu *iommu,
                                 unsigned int timeout_base)
{
    uint32_t cmd[4];
    s_time_t start, timeout;
    static unsigned int __read_mostly threshold = 1;

    /* RW1C 'ComWaitInt' in status register */
    writel(IOMMU_STATUS_COMP_WAIT_INT,
           iommu->mmio_base + IOMMU_STATUS_MMIO_OFFSET);

    /* send an empty COMPLETION_WAIT command to flush command buffer */
    cmd[3] = cmd[2] = 0;
    set_field_in_reg_u32(IOMMU_CMD_COMPLETION_WAIT, 0,
                         IOMMU_CMD_OPCODE_MASK,
                         IOMMU_CMD_OPCODE_SHIFT, &cmd[1]);
    set_field_in_reg_u32(IOMMU_CONTROL_ENABLED, 0,
                         IOMMU_COMP_WAIT_I_FLAG_MASK,
                         IOMMU_COMP_WAIT_I_FLAG_SHIFT, &cmd[0]);
    send_iommu_command(iommu, cmd);

    start = NOW();
    timeout = start + (timeout_base ?: 100) * MILLISECS(threshold);
    while ( !(readl(iommu->mmio_base + IOMMU_STATUS_MMIO_OFFSET) &
              IOMMU_STATUS_COMP_WAIT_INT) )
    {
        if ( timeout && NOW() > timeout )
        {
            threshold |= threshold << 1;
            printk(XENLOG_WARNING
                   "AMD IOMMU %pp: %scompletion wait taking too long\n",
                   &PCI_SBDF2(iommu->seg, iommu->bdf),
                   timeout_base ? "iotlb " : "");
            timeout = 0;
        }
        cpu_relax();
    }

    if ( !timeout )
        printk(XENLOG_WARNING
               "AMD IOMMU %pp: %scompletion wait took %lums\n",
               &PCI_SBDF2(iommu->seg, iommu->bdf),
               timeout_base ? "iotlb " : "",
               (NOW() - start) / 10000000);
}
