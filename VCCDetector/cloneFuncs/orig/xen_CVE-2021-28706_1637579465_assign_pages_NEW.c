int assign_pages(
    struct page_info *pg,
    unsigned int nr,
    struct domain *d,
    unsigned int memflags)
{
    int rc = 0;
    unsigned int i;

    spin_lock(&d->page_alloc_lock);

    if ( unlikely(d->is_dying) )
    {
        gdprintk(XENLOG_INFO, "Cannot assign page to domain%d -- dying.\n",
                d->domain_id);
        rc = -EINVAL;
        goto out;
    }

#ifndef NDEBUG
    {
        unsigned int extra_pages = 0;

        for ( i = 0; i < nr; i++ )
        {
            ASSERT(!(pg[i].count_info & ~(PGC_extra | PGC_reserved)));
            if ( pg[i].count_info & PGC_extra )
                extra_pages++;
        }

        ASSERT(!extra_pages ||
               ((memflags & MEMF_no_refcount) &&
                extra_pages == nr));
    }
#endif

    if ( pg[0].count_info & PGC_extra )
    {
        d->extra_pages += nr;
        memflags &= ~MEMF_no_refcount;
    }
    else if ( !(memflags & MEMF_no_refcount) )
    {
        unsigned int tot_pages = domain_tot_pages(d);

        if ( unlikely(tot_pages > d->max_pages) )
        {
            gprintk(XENLOG_INFO, "Inconsistent allocation for %pd: %u > %u\n",
                    d, tot_pages, d->max_pages);
            rc = -EPERM;
            goto out;
        }

        if ( unlikely(nr > d->max_pages - tot_pages) )
        {
            gprintk(XENLOG_INFO, "Over-allocation for %pd: %Lu > %u\n",
                    d, tot_pages + 0ull + nr, d->max_pages);
            rc = -E2BIG;
            goto out;
        }
    }

    if ( !(memflags & MEMF_no_refcount) )
    {
        if ( unlikely(d->tot_pages + nr < nr) )
        {
            gprintk(XENLOG_INFO,
                    "Excess allocation for %pd: %Lu (%u extra)\n",
                    d, d->tot_pages + 0ull + nr, d->extra_pages);
            if ( pg[0].count_info & PGC_extra )
                d->extra_pages -= nr;
            rc = -E2BIG;
            goto out;
        }

        if ( unlikely(domain_adjust_tot_pages(d, nr) == nr) )
            get_knownalive_domain(d);
    }

    for ( i = 0; i < nr; i++ )
    {
        ASSERT(page_get_owner(&pg[i]) == NULL);
        page_set_owner(&pg[i], d);
        smp_wmb(); /* Domain pointer must be visible before updating refcnt. */
        pg[i].count_info =
            (pg[i].count_info & (PGC_extra | PGC_reserved)) | PGC_allocated | 1;

        page_list_add_tail(&pg[i], page_to_list(d, &pg[i]));
    }

 out:
    spin_unlock(&d->page_alloc_lock);
    return rc;
}
