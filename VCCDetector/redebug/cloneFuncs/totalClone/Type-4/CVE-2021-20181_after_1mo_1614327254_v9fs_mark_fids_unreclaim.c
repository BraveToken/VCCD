static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, *fidp_next;

    fidp = QSIMPLEQ_FIRST(&s->fid_list);
    if (!fidp) {
        return 0;
    }

    /*
     * v9fs_reopen_fid() can yield : a reference on the fid must be held
     * to ensure its pointer remains valid and we can safely pass it to
     * QSIMPLEQ_NEXT(). The corresponding put_fid() can also yield so
     * we must keep a reference on the next fid as well. So the logic here
     * is to get a reference on a fid and only put it back during the next
     * iteration after we could get a reference on the next fid. Start with
     * the first one.
     */
    for (fidp->ref++; fidp; fidp = fidp_next) {
        if (fidp->path.size == path->size &&
            !memcmp(fidp->path.data, path->data, path->size)) {
            /* Mark the fid non reclaimable. */
            fidp->flags |= FID_NON_RECLAIMABLE;

            /* reopen the file/dir if already closed */
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                put_fid(pdu, fidp);
                return err;
            }
        }

        fidp_next = QSIMPLEQ_NEXT(fidp, next);

        if (fidp_next) {
            /*
             * Ensure the next fid survives a potential clunk request during
             * put_fid() below and v9fs_reopen_fid() in the next iteration.
             */
            fidp_next->ref++;
        }

        /* We're done with this fid */
        put_fid(pdu, fidp);
    }

    return 0;
}
