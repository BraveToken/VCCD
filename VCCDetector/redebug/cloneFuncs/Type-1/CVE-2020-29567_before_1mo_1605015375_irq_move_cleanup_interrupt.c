void irq_move_cleanup_interrupt(struct cpu_user_regs *regs)
{
    unsigned vector, me;

    /* This interrupt should not nest inside others. */
    BUILD_BUG_ON(APIC_PRIO_CLASS(IRQ_MOVE_CLEANUP_VECTOR) !=
                 APIC_PRIO_CLASS(FIRST_DYNAMIC_VECTOR));

    ack_APIC_irq();

    me = smp_processor_id();
    if ( !cpu_online(me) )
        return;

    for ( vector = FIRST_DYNAMIC_VECTOR;
          vector <= LAST_HIPRIORITY_VECTOR; vector++)
    {
        unsigned int irq;
        unsigned int irr;
        struct irq_desc *desc;
        irq = per_cpu(vector_irq, me)[vector];

        if ((int)irq < 0)
            continue;

        desc = irq_to_desc(irq);
        if (!desc)
            continue;

        spin_lock(&desc->lock);

        if (desc->handler->enable == enable_8259A_irq)
            goto unlock;

        if (!desc->arch.move_cleanup_count)
            goto unlock;

        if ( vector == desc->arch.vector &&
             cpumask_test_cpu(me, desc->arch.cpu_mask) )
            goto unlock;

        irr = apic_read(APIC_IRR + (vector / 32 * 0x10));
        /*
         * Check if the vector that needs to be cleanedup is
         * registered at the cpu's IRR. If so, then this is not
         * the best time to clean it up. Lets clean it up in the
         * next attempt by sending another IRQ_MOVE_CLEANUP_VECTOR
         * to myself.
         */
        if ( irr & (1u << (vector % 32)) )
        {
            send_IPI_self(IRQ_MOVE_CLEANUP_VECTOR);
            TRACE_3D(TRC_HW_IRQ_MOVE_CLEANUP_DELAY,
                     irq, vector, smp_processor_id());
            goto unlock;
        }

        TRACE_3D(TRC_HW_IRQ_MOVE_CLEANUP,
                 irq, vector, smp_processor_id());

        per_cpu(vector_irq, me)[vector] = ~irq;
        desc->arch.move_cleanup_count--;

        if ( desc->arch.move_cleanup_count == 0 )
        {
            ASSERT(vector == desc->arch.old_vector);
            release_old_vec(desc);
        }
unlock:
        spin_unlock(&desc->lock);
    }
}
