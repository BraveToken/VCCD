static void sh_pagetable_dying(struct vcpu *v, paddr_t gpa)
{
    mfn_t smfn, gmfn;
    p2m_type_t p2mt;

    gmfn = get_gfn_query(v->domain, _gfn(gpa >> PAGE_SHIFT), &p2mt);
    paging_lock(v->domain);

#if GUEST_PAGING_LEVELS == 2
    smfn = shadow_hash_lookup(v, mfn_x(gmfn), SH_type_l2_32_shadow);
#else
    smfn = shadow_hash_lookup(v, mfn_x(gmfn), SH_type_l4_64_shadow);
#endif
    
    if ( mfn_valid(smfn) )
    {
        mfn_to_page(gmfn)->shadow_flags |= SHF_pagetable_dying;
        shadow_unhook_mappings(v, smfn, 1/* user pages only */);
        /* Now flush the TLB: we removed toplevel mappings. */
        flush_tlb_mask(v->domain->domain_dirty_cpumask);
    }

    /* Remember that we've seen the guest use this interface, so we
     * can rely on it using it in future, instead of guessing at
     * when processes are being torn down. */
    v->domain->arch.paging.shadow.pagetable_dying_op = 1;

    v->arch.paging.shadow.pagetable_dying = 1;

    paging_unlock(v->domain);
    put_gfn(v->domain, gpa >> PAGE_SHIFT);
}
