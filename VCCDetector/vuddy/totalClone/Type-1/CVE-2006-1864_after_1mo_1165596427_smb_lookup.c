static struct dentry *
smb_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd)
{
	struct smb_fattr finfo;
	struct inode *inode;
	int error;
	struct smb_sb_info *server;

	error = -ENAMETOOLONG;
	if (dentry->d_name.len > SMB_MAXNAMELEN)
		goto out;

	/* Do not allow lookup of names with backslashes in */
	error = -EINVAL;
	if (memchr(dentry->d_name.name, '\\', dentry->d_name.len))
		goto out;

	lock_kernel();
	error = smb_proc_getattr(dentry, &finfo);
#ifdef SMBFS_PARANOIA
	if (error && error != -ENOENT)
		PARANOIA("find %s/%s failed, error=%d\n",
			 DENTRY_PATH(dentry), error);
#endif

	inode = NULL;
	if (error == -ENOENT)
		goto add_entry;
	if (!error) {
		error = -EACCES;
		finfo.f_ino = iunique(dentry->d_sb, 2);
		inode = smb_iget(dir->i_sb, &finfo);
		if (inode) {
	add_entry:
			server = server_from_dentry(dentry);
			if (server->mnt->flags & SMB_MOUNT_CASE)
				dentry->d_op = &smbfs_dentry_operations_case;
			else
				dentry->d_op = &smbfs_dentry_operations;

			d_add(dentry, inode);
			smb_renew_times(dentry);
			error = 0;
		}
	}
	unlock_kernel();
out:
	return ERR_PTR(error);
}
