static bool ath10k_htt_rx_proc_rx_frag_ind_hl(struct ath10k_htt *htt,
					      struct htt_rx_fragment_indication *rx,
					      struct sk_buff *skb)
{
	struct ath10k *ar = htt->ar;
	enum htt_rx_tkip_demic_type tkip_mic = HTT_RX_NON_TKIP_MIC;
	enum htt_txrx_sec_cast_type sec_index;
	struct htt_rx_indication_hl *rx_hl;
	enum htt_security_types sec_type;
	u32 tid, frag, seq, rx_desc_info;
	union htt_rx_pn_t new_pn = {0};
	struct htt_hl_rx_desc *rx_desc;
	u16 peer_id, sc, hdr_space;
	union htt_rx_pn_t *last_pn;
	struct ieee80211_hdr *hdr;
	int ret, num_mpdu_ranges;
	struct ath10k_peer *peer;
	struct htt_resp *resp;
	size_t tot_hdr_len;

	resp = (struct htt_resp *)(skb->data + HTT_RX_FRAG_IND_INFO0_HEADER_LEN);
	skb_pull(skb, HTT_RX_FRAG_IND_INFO0_HEADER_LEN);
	skb_trim(skb, skb->len - FCS_LEN);

	peer_id = __le16_to_cpu(rx->peer_id);
	rx_hl = (struct htt_rx_indication_hl *)(&resp->rx_ind_hl);

	spin_lock_bh(&ar->data_lock);
	peer = ath10k_peer_find_by_id(ar, peer_id);
	if (!peer) {
		ath10k_dbg(ar, ATH10K_DBG_HTT, "invalid peer: %u\n", peer_id);
		goto err;
	}

	num_mpdu_ranges = MS(__le32_to_cpu(rx_hl->hdr.info1),
			     HTT_RX_INDICATION_INFO1_NUM_MPDU_RANGES);

	tot_hdr_len = sizeof(struct htt_resp_hdr) +
		      sizeof(rx_hl->hdr) +
		      sizeof(rx_hl->ppdu) +
		      sizeof(rx_hl->prefix) +
		      sizeof(rx_hl->fw_desc) +
		      sizeof(struct htt_rx_indication_mpdu_range) * num_mpdu_ranges;

	tid =  MS(rx_hl->hdr.info0, HTT_RX_INDICATION_INFO0_EXT_TID);
	rx_desc = (struct htt_hl_rx_desc *)(skb->data + tot_hdr_len);
	rx_desc_info = __le32_to_cpu(rx_desc->info);

	hdr = (struct ieee80211_hdr *)((u8 *)rx_desc + rx_hl->fw_desc.len);

	if (is_multicast_ether_addr(hdr->addr1)) {
		/* Discard the fragment with multicast DA */
		goto err;
	}

	if (!MS(rx_desc_info, HTT_RX_DESC_HL_INFO_ENCRYPTED)) {
		spin_unlock_bh(&ar->data_lock);
		return ath10k_htt_rx_proc_rx_ind_hl(htt, &resp->rx_ind_hl, skb,
						    HTT_RX_NON_PN_CHECK,
						    HTT_RX_NON_TKIP_MIC);
	}

	if (ieee80211_has_retry(hdr->frame_control))
		goto err;

	hdr_space = ieee80211_hdrlen(hdr->frame_control);
	sc = __le16_to_cpu(hdr->seq_ctrl);
	seq = (sc & IEEE80211_SCTL_SEQ) >> 4;
	frag = sc & IEEE80211_SCTL_FRAG;

	sec_index = MS(rx_desc_info, HTT_RX_DESC_HL_INFO_MCAST_BCAST) ?
		    HTT_TXRX_SEC_MCAST : HTT_TXRX_SEC_UCAST;
	sec_type = peer->rx_pn[sec_index].sec_type;
	ath10k_htt_rx_mpdu_desc_pn_hl(rx_desc, &new_pn, peer->rx_pn[sec_index].pn_len);

	switch (sec_type) {
	case HTT_SECURITY_TKIP:
		tkip_mic = HTT_RX_TKIP_MIC;
		ret = ath10k_htt_rx_frag_tkip_decap_withmic(skb,
							    tot_hdr_len +
							    rx_hl->fw_desc.len,
							    hdr_space);
		if (ret)
			goto err;
		break;
	case HTT_SECURITY_TKIP_NOMIC:
		ret = ath10k_htt_rx_frag_tkip_decap_nomic(skb,
							  tot_hdr_len +
							  rx_hl->fw_desc.len,
							  hdr_space);
		if (ret)
			goto err;
		break;
	case HTT_SECURITY_AES_CCMP:
		ret = ath10k_htt_rx_frag_ccmp_decap(skb,
						    tot_hdr_len + rx_hl->fw_desc.len,
						    hdr_space);
		if (ret)
			goto err;
		break;
	case HTT_SECURITY_WEP128:
	case HTT_SECURITY_WEP104:
	case HTT_SECURITY_WEP40:
		ret = ath10k_htt_rx_frag_wep_decap(skb,
						   tot_hdr_len + rx_hl->fw_desc.len,
						   hdr_space);
		if (ret)
			goto err;
		break;
	default:
		break;
	}

	resp = (struct htt_resp *)(skb->data);

	if (sec_type != HTT_SECURITY_AES_CCMP &&
	    sec_type != HTT_SECURITY_TKIP &&
	    sec_type != HTT_SECURITY_TKIP_NOMIC) {
		spin_unlock_bh(&ar->data_lock);
		return ath10k_htt_rx_proc_rx_ind_hl(htt, &resp->rx_ind_hl, skb,
						    HTT_RX_NON_PN_CHECK,
						    HTT_RX_NON_TKIP_MIC);
	}

	last_pn = &peer->frag_tids_last_pn[tid];

	if (frag == 0) {
		if (ath10k_htt_rx_pn_check_replay_hl(ar, peer, &resp->rx_ind_hl))
			goto err;

		last_pn->pn48 = new_pn.pn48;
		peer->frag_tids_seq[tid] = seq;
	} else if (sec_type == HTT_SECURITY_AES_CCMP) {
		if (seq != peer->frag_tids_seq[tid])
			goto err;

		if (new_pn.pn48 != last_pn->pn48 + 1)
			goto err;

		last_pn->pn48 = new_pn.pn48;
		last_pn = &peer->tids_last_pn[tid];
		last_pn->pn48 = new_pn.pn48;
	}

	spin_unlock_bh(&ar->data_lock);

	return ath10k_htt_rx_proc_rx_ind_hl(htt, &resp->rx_ind_hl, skb,
					    HTT_RX_NON_PN_CHECK, tkip_mic);

err:
	spin_unlock_bh(&ar->data_lock);

	/* Tell the caller that it must free the skb since we have not
	 * consumed it
	 */
	return true;
}
