int ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                         AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    VP56Context *s = avctx->priv_data;
    AVFrame *p = 0;
    int remaining_buf_size = avpkt->size;
    int av_uninit(alpha_offset);
    int i, res;

    /* select a current frame from the unused frames */
    for (i = 0; i < 4; ++i) {
        if (!s->frames[i].data[0]) {
            p = &s->frames[i];
            break;
        }
    }
    av_assert0(p != 0);
    s->framep[VP56_FRAME_CURRENT] = p;
    if (s->alpha_context)
        s->alpha_context->framep[VP56_FRAME_CURRENT] = p;

    if (s->has_alpha) {
        if (remaining_buf_size < 3)
            return -1;
        alpha_offset = bytestream_get_be24(&buf);
        remaining_buf_size -= 3;
        if (remaining_buf_size < alpha_offset)
            return -1;
    }

    res = s->parse_header(s, buf, remaining_buf_size);
    if (res < 0)
        return res;

    if (res == VP56_SIZE_CHANGE) {
        for (i = 0; i < 4; i++) {
            if (s->frames[i].data[0])
                avctx->release_buffer(avctx, &s->frames[i]);
        }
    }

    p->reference = 3;
    if (ff_get_buffer(avctx, p) < 0) {
        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
        return -1;
    }

    if (res == VP56_SIZE_CHANGE) {
        if (vp56_size_changed(s)) {
            avctx->release_buffer(avctx, p);
            return -1;
        }
    }

    if (s->has_alpha) {
        int bak_w = avctx->width;
        int bak_h = avctx->height;
        int bak_cw = avctx->coded_width;
        int bak_ch = avctx->coded_height;
        buf += alpha_offset;
        remaining_buf_size -= alpha_offset;

        res = s->alpha_context->parse_header(s->alpha_context, buf, remaining_buf_size);
        if (res != 0) {
            if(res==VP56_SIZE_CHANGE) {
                av_log(avctx, AV_LOG_ERROR, "Alpha reconfiguration\n");
                avctx->width  = bak_w;
                avctx->height = bak_h;
                avctx->coded_width  = bak_cw;
                avctx->coded_height = bak_ch;
            }
            avctx->release_buffer(avctx, p);
            return -1;
        }
    }

    avctx->execute2(avctx, ff_vp56_decode_mbs, 0, 0, s->has_alpha + 1);

    /* release frames that aren't in use */
    for (i = 0; i < 4; ++i) {
        AVFrame *victim = &s->frames[i];
        if (!victim->data[0])
            continue;
        if (victim != s->framep[VP56_FRAME_PREVIOUS] &&
            victim != s->framep[VP56_FRAME_GOLDEN] &&
            (!s->has_alpha || victim != s->alpha_context->framep[VP56_FRAME_GOLDEN]))
            avctx->release_buffer(avctx, victim);
    }

    p->qstride = 0;
    p->qscale_table = s->qscale_table;
    p->qscale_type = FF_QSCALE_TYPE_VP56;
    *(AVFrame*)data = *p;
    *got_frame = 1;

    return avpkt->size;
}
