static void flush_command_buffer(struct amd_iommu *iommu,
                                 unsigned int timeout_base)
{
    static DEFINE_PER_CPU(uint64_t, poll_slot);
    uint64_t *this_poll_slot = &this_cpu(poll_slot);
    paddr_t addr = virt_to_maddr(this_poll_slot);
    /* send a COMPLETION_WAIT command to flush command buffer */
    uint32_t cmd[4] = {
        addr | MASK_INSR(IOMMU_CONTROL_ENABLED,
                         IOMMU_COMP_WAIT_S_FLAG_MASK),
        (addr >> 32) | MASK_INSR(IOMMU_CMD_COMPLETION_WAIT,
                                 IOMMU_CMD_OPCODE_MASK),
        CMD_COMPLETION_DONE
    };
    s_time_t start, timeout;
    static unsigned int __read_mostly threshold = 1;

    ACCESS_ONCE(*this_poll_slot) = CMD_COMPLETION_INIT;

    send_iommu_command(iommu, cmd);

    start = NOW();
    timeout = start + (timeout_base ?: 100) * MILLISECS(threshold);
    while ( ACCESS_ONCE(*this_poll_slot) != CMD_COMPLETION_DONE )
    {
        if ( timeout && NOW() > timeout )
        {
            threshold |= threshold << 1;
            printk(XENLOG_WARNING
                   "AMD IOMMU %pp: %scompletion wait taking too long\n",
                   &PCI_SBDF2(iommu->seg, iommu->bdf),
                   timeout_base ? "iotlb " : "");
            timeout = 0;
        }
        cpu_relax();
    }

    if ( !timeout )
        printk(XENLOG_WARNING
               "AMD IOMMU %pp: %scompletion wait took %lums\n",
               &PCI_SBDF2(iommu->seg, iommu->bdf),
               timeout_base ? "iotlb " : "",
               (NOW() - start) / 10000000);
}
