static void usb_mtp_write_data(MTPState *s, uint32_t handle)
{
    MTPData *d = s->data_out;
    MTPObject *parent =
        usb_mtp_object_lookup(s, s->dataset.parent_handle);
    char *path = NULL;
    uint64_t rc;
    mode_t mask = 0644;
    int ret = 0;

    assert(d != NULL);

    switch (d->write_status) {
    case WRITE_START:
        if (!parent || !s->write_pending) {
            usb_mtp_queue_result(s, RES_INVALID_OBJECTINFO, d->trans,
                0, 0, 0, 0);
            return;
        }

        if (s->dataset.filename) {
            path = g_strdup_printf("%s/%s", parent->path, s->dataset.filename);
            if (s->dataset.format == FMT_ASSOCIATION) {
                ret = mkdir(path, mask);
                if (!ret) {
                    usb_mtp_queue_result(s, RES_OK, d->trans, 3,
                                         QEMU_STORAGE_ID,
                                         s->dataset.parent_handle,
                                         handle);
                    goto close;
                }
                goto done;
            }

            d->fd = open(path, O_CREAT | O_WRONLY |
                         O_CLOEXEC | O_NOFOLLOW, mask);
            if (d->fd == -1) {
                ret = 1;
                goto done;
            }

            /* Return success if initiator sent 0 sized data */
            if (!s->dataset.size) {
                goto done;
            }
            if (d->length != MTP_WRITE_BUF_SZ && !d->pending) {
                d->write_status = WRITE_END;
            }
        }
        /* fall through */
    case WRITE_CONTINUE:
    case WRITE_END:
        rc = write_retry(d->fd, d->data, d->data_offset,
                         d->offset - d->data_offset);
        if (rc != d->data_offset) {
            ret = 1;
            goto done;
        }
        if (d->write_status != WRITE_END) {
            g_free(path);
            return;
        } else {
            /*
             * Return an incomplete transfer if file size doesn't match
             * for < 4G file or if lstat fails which will result in an incorrect
             * file size
             */
            if ((s->dataset.size != 0xFFFFFFFF &&
                 d->offset != s->dataset.size) ||
                usb_mtp_update_object(parent, s->dataset.filename)) {
                usb_mtp_queue_result(s, RES_INCOMPLETE_TRANSFER, d->trans,
                                     0, 0, 0, 0);
                goto close;
            }
        }
    }

done:
    if (ret) {
        usb_mtp_queue_result(s, RES_STORE_FULL, d->trans,
                             0, 0, 0, 0);
    } else {
        usb_mtp_queue_result(s, RES_OK, d->trans,
                             0, 0, 0, 0);
    }
close:
    /*
     * The write dataset is kept around and freed only
     * on success or if another write request comes in
     */
    if (d->fd != -1) {
        close(d->fd);
        d->fd = -1;
    }
    g_free(s->dataset.filename);
    s->dataset.size = 0;
    g_free(path);
    s->write_pending = false;
}
