static int lo_do_open(struct lo_data *lo, struct lo_inode *inode,
                      struct fuse_file_info *fi)
{
    char buf[64];
    ssize_t fh;
    int fd;

    update_open_flags(lo->writeback, lo->allow_direct_io, fi);

    sprintf(buf, "%i", inode->fd);
    fd = openat(lo->proc_self_fd, buf, fi->flags & ~O_NOFOLLOW);
    if (fd == -1) {
        return errno;
    }

    pthread_mutex_lock(&lo->mutex);
    fh = lo_add_fd_mapping(lo, fd);
    pthread_mutex_unlock(&lo->mutex);
    if (fh == -1) {
        close(fd);
        return ENOMEM;
    }

    fi->fh = fh;
    if (lo->cache == CACHE_NONE) {
        fi->direct_io = 1;
    } else if (lo->cache == CACHE_ALWAYS) {
        fi->keep_cache = 1;
    }
    return 0;
}
